---
layout: post
title:  "IDE Pitfalls"
date:   2013-12-01 6:18:38
categories: post
tags: java
---

I have participated in a code review session this week and caught an endemic issue in today's java projects: code generated by IDE. I'm not against them, but just as everything else, it should be used with moderation. Consider the `Customer` class below, getters and setters methods were automatically generated.

{% highlight java linenos %}
public class Customer {
    private String name;
    private List<Address> address;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<Address> getAddress() {
        return address;
    }

    public void setAddress(List<Address> address) {
        this.address = address;
    }
}
{% endhighlight %}

Then there is a piece of code doing some logic with the customer's billing address.

	customer.getAddress().get(0).getLine1();

Developer assumed the billing address would always be the first address returned by the back-end system. As this is such a dangerous assumption, my first suggestion was to refactor this code to explicitly ask for the billing address.


{% highlight java %}
    public Address getBillingAddress() {
        for(Address a: address) {
            if (a.getType().equals(AddressType.BILLING)) {
                return  a;
            }
        }
        return new Address();
    }
{% endhighlight %}

Now the calling method would no longer be prone to `NullPointer` exceptions and the code is easier to understand.

	customer.getBillingAddress.getLine1();

This solution is good until we need to do the same for the Shipping address or any other address type that will be added in the future. The problem is that we would repeat this logic over for every address type. In order to avoid that we simply changed the auto-generated `getAddress` method to look like below:

{% highlight java %}
    public Address getAddress(AddressType type) {
        for(Address a: address) {
            if (a.getType().equals(type)) {
                return a;
            }
        }
        return new Address();
    }
{% endhighlight %}

The last thing to note is that whenever the address type is not found, instead of returning `null`, we chose to return an empty `Address`. This can be a problem if `Address` constructor defaults the `AddressType` to `BILLING` for example. In this case we could create a new `AddressType` to represent a NullObject `Address`. Search 'Null Object Pattern' on google for more information about that.
